# Map Tab Implementation Plan

## Phase 1: Backend API + Basic Hex Map

### Files Changed

| File                                | Changes                                                                   |
| ----------------------------------- | ------------------------------------------------------------------------- |
| `src-tauri/src/lib.rs`              | Add `MapTile` struct with ts-rs export, add `get_map_tiles` Tauri command |
| `src/lib/types/MapTile.ts`          | Auto-generated by ts-rs                                                   |
| `src/lib/types/index.ts`            | Re-export `MapTile` type                                                  |
| `src/lib/api.ts`                    | Add `getMapTiles(matchId)` method                                         |
| `src/lib/config/terrain.ts`         | New file: terrain/height/vegetation color constants                       |
| `src/lib/config/index.ts`           | Re-export terrain colors                                                  |
| `src/lib/HexMap.svelte`             | New component: ECharts custom series hex renderer                         |
| `src/routes/game/[id]/+page.svelte` | Add Map tab trigger and content                                           |

### 1.1 Backend: MapTile struct and command

**`src-tauri/src/lib.rs`** - Add after other struct definitions (~line 200):

```rust
#[derive(Serialize, TS)]
#[ts(export, export_to = "../../src/lib/types/")]
pub struct MapTile {
    pub x: i32,
    pub y: i32,
    pub terrain: Option<String>,
    pub height: Option<String>,
    pub vegetation: Option<String>,
    pub resource: Option<String>,
    pub improvement: Option<String>,
    pub has_road: bool,
    pub owner_nation: Option<String>,  // Resolved from owner_player_id -> players.nation
}
```

**`src-tauri/src/lib.rs`** - Add command (~after other get\_\* commands):

```rust
#[tauri::command]
async fn get_map_tiles(
    match_id: i64,
    pool: tauri::State<'_, db::connection::DbPool>,
) -> Result<Vec<MapTile>, String> {
    pool.with_connection(|conn| {
        let mut stmt = conn.prepare(
            "SELECT t.x, t.y, t.terrain, t.height, t.vegetation,
                    t.resource, t.improvement, t.has_road, p.nation
             FROM tiles t
             LEFT JOIN players p ON t.owner_player_id = p.player_id AND t.match_id = p.match_id
             WHERE t.match_id = ?
             ORDER BY t.y, t.x"
        )?;

        let tiles = stmt
            .query_map([match_id], |row| {
                Ok(MapTile {
                    x: row.get(0)?,
                    y: row.get(1)?,
                    terrain: row.get(2)?,
                    height: row.get(3)?,
                    vegetation: row.get(4)?,
                    resource: row.get(5)?,
                    improvement: row.get(6)?,
                    has_road: row.get(7)?,
                    owner_nation: row.get(8)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;

        Ok(tiles)
    })
    .context("Failed to get map tiles")
    .map_err(|e| e.to_string())
}
```

**`src-tauri/src/lib.rs`** - Register in `generate_handler!` macro (~line 1685):

```rust
get_map_tiles,
```

### 1.2 Frontend Types

**`src/lib/types/index.ts`** - Add export:

```typescript
export type { MapTile } from "./MapTile";
```

### 1.3 API Layer

**`src/lib/api.ts`** - Add import and method:

```typescript
import type { MapTile } from "$lib/types/MapTile";

// In api object:
getMapTiles: (matchId: number) =>
  invoke<MapTile[]>("get_map_tiles", { matchId }),
```

### 1.4 Terrain Colors Config

**`src/lib/config/terrain.ts`** - New file:

```typescript
/**
 * Terrain visualization colors for hex map
 */

export const TERRAIN_COLORS: Record<string, string> = {
	TERRAIN_WATER: "#1a5276",
	TERRAIN_COAST: "#2980b9",
	TERRAIN_TEMPERATE: "#27ae60",
	TERRAIN_ARID: "#d4ac6e",
	TERRAIN_TUNDRA: "#bdc3c7",
	TERRAIN_DESERT: "#f4d03f",
};

export const HEIGHT_COLORS: Record<string, string> = {
	HEIGHT_OCEAN: "#154360",
	HEIGHT_FLAT: "#58d68d",
	HEIGHT_HILL: "#a04000",
	HEIGHT_MOUNTAIN: "#7f8c8d",
};

export const VEGETATION_COLORS: Record<string, string> = {
	VEGETATION_NONE: "#d4ac6e",
	VEGETATION_TREES: "#1e8449",
	VEGETATION_SCRUB: "#7d6608",
	VEGETATION_MARSH: "#45b39d",
};

export const UNOWNED_TILE_COLOR = "#444444";

export function getTerrainColor(terrain: string | null): string {
	if (!terrain) return UNOWNED_TILE_COLOR;
	return TERRAIN_COLORS[terrain] ?? UNOWNED_TILE_COLOR;
}

export function getHeightColor(height: string | null): string {
	if (!height) return UNOWNED_TILE_COLOR;
	return HEIGHT_COLORS[height] ?? UNOWNED_TILE_COLOR;
}

export function getVegetationColor(vegetation: string | null): string {
	if (!vegetation) return VEGETATION_COLORS.VEGETATION_NONE;
	return VEGETATION_COLORS[vegetation] ?? VEGETATION_COLORS.VEGETATION_NONE;
}
```

**`src/lib/config/index.ts`** - Add re-exports:

```typescript
export {
	TERRAIN_COLORS,
	HEIGHT_COLORS,
	VEGETATION_COLORS,
	getTerrainColor,
	getHeightColor,
	getVegetationColor,
} from "./terrain";
```

### 1.5 HexMap Component

**`src/lib/HexMap.svelte`** - New file:

```svelte
<script lang="ts">
	import { onMount, tick } from "svelte";
	import * as echarts from "echarts";
	import type { MapTile } from "$lib/types/MapTile";
	import { getCivilizationColor } from "$lib/config";

	type ColorMode =
		| "political"
		| "terrain"
		| "height"
		| "vegetation"
		| "resource";

	let {
		tiles,
		colorMode = "political",
		height = "600px",
	}: {
		tiles: MapTile[];
		colorMode?: ColorMode;
		height?: string;
	} = $props();

	let chartContainer: HTMLDivElement;
	let chart: echarts.ECharts | null = null;

	// Hex geometry constants (flat-top orientation)
	const HEX_SIZE = 10;
	const HEX_WIDTH = HEX_SIZE * 2;
	const HEX_HEIGHT = Math.sqrt(3) * HEX_SIZE;

	/**
	 * Convert axial hex coordinates to pixel position
	 * Flat-top hex: odd rows offset right by half width
	 */
	function hexToPixel(x: number, y: number): [number, number] {
		const px = x * HEX_WIDTH * 0.75;
		const py = y * HEX_HEIGHT + (x % 2 === 1 ? HEX_HEIGHT / 2 : 0);
		return [px, py];
	}

	/**
	 * Generate vertices for a flat-top hexagon centered at origin
	 */
	function hexVertices(cx: number, cy: number, size: number): number[][] {
		const vertices: number[][] = [];
		for (let i = 0; i < 6; i++) {
			const angle = (Math.PI / 3) * i;
			vertices.push([cx + size * Math.cos(angle), cy + size * Math.sin(angle)]);
		}
		return vertices;
	}

	/**
	 * Get tile color based on current color mode.
	 * In political mode, unowned tiles show terrain color.
	 */
	function getTileColor(tile: MapTile, mode: ColorMode): string {
		switch (mode) {
			case "political":
				if (tile.owner_nation) {
					return (
						getCivilizationColor(tile.owner_nation.replace("NATION_", "")) ??
						getTerrainColor(tile.terrain)
					);
				}
				return getTerrainColor(tile.terrain);
			case "terrain":
				return getTerrainColor(tile.terrain);
			case "height":
				return getHeightColor(tile.height);
			case "vegetation":
				return getVegetationColor(tile.vegetation);
			case "resource":
				return tile.resource ? "#FFD700" : getTerrainColor(tile.terrain);
			default:
				return getTerrainColor(tile.terrain);
		}
	}

	// Import color functions
	import {
		getTerrainColor,
		getHeightColor,
		getVegetationColor,
	} from "$lib/config";

	function buildChartOption() {
		if (!tiles.length) return null;

		return {
			backgroundColor: "#1a1a1a",
			animation: false,
			tooltip: {
				trigger: "item",
				formatter: (params: { data: { tile: MapTile } }) => {
					const t = params.data.tile;
					return `(${t.x}, ${t.y})<br/>
            Terrain: ${t.terrain ?? "?"}<br/>
            Height: ${t.height ?? "?"}<br/>
            Owner: ${t.owner_nation?.replace("NATION_", "") ?? "None"}`;
				},
			},
			xAxis: { show: false, min: "dataMin", max: "dataMax" },
			yAxis: { show: false, min: "dataMin", max: "dataMax", inverse: true },
			dataZoom: [
				{ type: "inside", xAxisIndex: 0, minSpan: 10 },
				{ type: "inside", yAxisIndex: 0, minSpan: 10 },
			],
			series: [
				{
					type: "custom",
					coordinateSystem: "cartesian2d",
					renderItem: (
						params: unknown,
						api: {
							value: (idx: number) => number;
							coord: (val: [number, number]) => [number, number];
							style: (opts: { fill: string }) => Record<string, unknown>;
						},
					) => {
						const px = api.value(0) as number;
						const py = api.value(1) as number;
						const [cx, cy] = api.coord([px, py]);
						const color = api.value(2) as unknown as string;

						return {
							type: "polygon",
							shape: { points: hexVertices(cx, cy, HEX_SIZE * 0.95) },
							style: api.style({ fill: color }),
						};
					},
					data: tiles.map((tile) => {
						const [px, py] = hexToPixel(tile.x, tile.y);
						return {
							value: [px, py, getTileColor(tile, colorMode)],
							tile,
						};
					}),
				},
			],
		};
	}

	const chartOption = $derived(buildChartOption());

	onMount(() => {
		let resizeObserver: ResizeObserver;

		const initChart = () => {
			if (!chartContainer || chartContainer.clientWidth === 0) return;
			if (!chart) {
				chart = echarts.init(chartContainer);
				if (chartOption) chart.setOption(chartOption as any);
			}
		};

		tick().then(() => {
			initChart();
			resizeObserver = new ResizeObserver(() => {
				if (!chart && chartContainer) initChart();
				chart?.resize();
			});
			resizeObserver.observe(chartContainer);
		});

		window.addEventListener("resize", () => chart?.resize());

		return () => {
			resizeObserver?.disconnect();
			chart?.dispose();
		};
	});

	$effect(() => {
		const opt = chartOption;
		if (chart && opt) {
			chart.setOption(opt as any, true);
		}
	});
</script>

<div class="w-full" style="height: {height}">
	<div bind:this={chartContainer} class="h-full w-full"></div>
</div>
```

### 1.6 Game Details Page Integration

**`src/routes/game/[id]/+page.svelte`** - Add import (~line 13):

```typescript
import HexMap from "$lib/HexMap.svelte";
import type { MapTile } from "$lib/types/MapTile";
```

**`src/routes/game/[id]/+page.svelte`** - Add state (~line 27):

```typescript
let mapTiles = $state<MapTile[] | null>(null);
```

**`src/routes/game/[id]/+page.svelte`** - Add to Promise.all data fetch (~line 630):

```typescript
api.getMapTiles(matchId),
```

And update destructuring:

```typescript
.then(([details, history, yields, events, laws, cities, tiles]) => {
  // ... existing assignments ...
  mapTiles = tiles;
})
```

**`src/routes/game/[id]/+page.svelte`** - Add tab trigger after Cities tab (~line 945):

```svelte
<Tabs.Trigger
	value="map"
	class="cursor-pointer border-2 border-b-0 border-r-0 border-black px-6 py-3 font-bold transition-all duration-200 hover:bg-tan-hover data-[state=active]:bg-[#35302B] data-[state=inactive]:bg-[#2a2622] data-[state=active]:text-tan data-[state=inactive]:text-tan"
>
	Map
</Tabs.Trigger>
```

Update Game Settings tab to remove `rounded-tr-lg` and add `border-r-0`.

**`src/routes/game/[id]/+page.svelte`** - Add tab content before Game Settings content:

```svelte
<Tabs.Content
	value="map"
	class="tab-pane min-h-[400px] rounded-b-lg border-2 border-t-0 border-black p-8"
	style="background-color: #35302B;"
>
	<h2 class="mb-4 mt-0 font-bold text-tan">World Map</h2>
	{#if mapTiles}
		<HexMap tiles={mapTiles} colorMode="political" height="600px" />
	{:else}
		<p class="italic text-brown">Loading map data...</p>
	{/if}
</Tabs.Content>
```

### 1.7 Unit Tests

**`src-tauri/tests/map_tiles_test.rs`** - New file:

```rust
//! Tests for map tile query functionality

use anyhow::Result;
use per_ankh_lib::db;
use tempfile::tempdir;

/// Test that get_map_tiles query returns expected structure
#[test]
fn test_map_tiles_query_structure() -> Result<()> {
    let _ = env_logger::builder().is_test(true).try_init();

    let temp_dir = tempdir()?;
    let db_path = temp_dir.path().join("test.db");
    let conn = db::connection::get_connection(&db_path)?;
    db::ensure_schema_ready(&conn)?;

    // Import a test save file
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let save_path = std::path::PathBuf::from(manifest_dir)
        .join("test-data/saves/OW-Babylonia-Year123-2024-01-31-22-44-04.zip");

    let result = per_ankh_lib::parser::import_save_file(
        save_path.to_str().unwrap(),
        &conn,
        None, None, None, None, None,
    )?;

    assert!(result.success);
    let match_id = result.match_id.unwrap();

    // Query tiles
    let mut stmt = conn.prepare(
        "SELECT COUNT(*) FROM tiles WHERE match_id = ?"
    )?;
    let tile_count: i64 = stmt.query_row([match_id], |row| row.get(0))?;

    assert!(tile_count > 0, "Should have imported tiles");

    // Verify joined query works
    let mut stmt = conn.prepare(
        "SELECT t.x, t.y, t.terrain, p.nation
         FROM tiles t
         LEFT JOIN players p ON t.owner_player_id = p.player_id AND t.match_id = p.match_id
         WHERE t.match_id = ?
         LIMIT 1"
    )?;

    let result: (i32, i32, Option<String>, Option<String>) = stmt.query_row(
        [match_id],
        |row| Ok((row.get(0)?, row.get(1)?, row.get(2)?, row.get(3)?))
    )?;

    // x and y should be non-negative
    assert!(result.0 >= 0);
    assert!(result.1 >= 0);

    Ok(())
}

/// Test coordinate bounds are reasonable
#[test]
fn test_map_tile_coordinates() -> Result<()> {
    let _ = env_logger::builder().is_test(true).try_init();

    let temp_dir = tempdir()?;
    let db_path = temp_dir.path().join("test.db");
    let conn = db::connection::get_connection(&db_path)?;
    db::ensure_schema_ready(&conn)?;

    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let save_path = std::path::PathBuf::from(manifest_dir)
        .join("test-data/saves/OW-Babylonia-Year123-2024-01-31-22-44-04.zip");

    let result = per_ankh_lib::parser::import_save_file(
        save_path.to_str().unwrap(),
        &conn,
        None, None, None, None, None,
    )?;

    let match_id = result.match_id.unwrap();

    // Get map dimensions from match
    let (width, height): (Option<i32>, Option<i32>) = conn.query_row(
        "SELECT map_width, map_height FROM matches WHERE match_id = ?",
        [match_id],
        |row| Ok((row.get(0)?, row.get(1)?))
    )?;

    // Get max tile coordinates
    let (max_x, max_y): (i32, i32) = conn.query_row(
        "SELECT MAX(x), MAX(y) FROM tiles WHERE match_id = ?",
        [match_id],
        |row| Ok((row.get(0)?, row.get(1)?))
    )?;

    // Coordinates should be within map bounds (if dimensions are known)
    if let (Some(w), Some(h)) = (width, height) {
        assert!(max_x < w, "Max X {} should be less than map width {}", max_x, w);
        assert!(max_y < h, "Max Y {} should be less than map height {}", max_y, h);
    }

    Ok(())
}
```

Run tests: `cargo test --test map_tiles_test`

---

## Phase 2: Color Mode Selector

### Files Changed

| File                                | Changes                                |
| ----------------------------------- | -------------------------------------- |
| `src/lib/HexMap.svelte`             | Add color mode buttons, expose as prop |
| `src/lib/config/terrain.ts`         | Add resource colors                    |
| `src/routes/game/[id]/+page.svelte` | Add color mode state, pass to HexMap   |

### 2.1 Add Resource Colors

**`src/lib/config/terrain.ts`** - Add resource color mapping:

```typescript
export const RESOURCE_COLORS: Record<string, string> = {
	// Strategic
	RESOURCE_IRON: "#708090",
	RESOURCE_STONE: "#A9A9A9",
	RESOURCE_WOOD: "#8B4513",
	RESOURCE_HORSES: "#D2691E",
	// Luxury
	RESOURCE_WINE: "#722F37",
	RESOURCE_WHEAT: "#F5DEB3",
	RESOURCE_GAME: "#228B22",
	RESOURCE_FISH: "#4682B4",
	RESOURCE_MARBLE: "#F5F5F5",
	RESOURCE_GEMS: "#E6E6FA",
	RESOURCE_INCENSE: "#DEB887",
	RESOURCE_SILK: "#FFD700",
	RESOURCE_SPICES: "#FF6347",
	RESOURCE_OLIVES: "#808000",
};

export const RESOURCE_DEFAULT_COLOR = "#FFD700";

export function getResourceColor(resource: string | null): string {
	if (!resource) return UNOWNED_TILE_COLOR;
	return RESOURCE_COLORS[resource] ?? RESOURCE_DEFAULT_COLOR;
}
```

**`src/lib/config/index.ts`** - Add to exports:

```typescript
export {
	// ... existing exports ...
	RESOURCE_COLORS,
	RESOURCE_DEFAULT_COLOR,
	getResourceColor,
} from "./terrain";
```

### 2.2 Update HexMap with Color Mode UI

**`src/lib/HexMap.svelte`** - Replace entire component:

```svelte
<script lang="ts">
  import { onMount, tick } from "svelte";
  import * as echarts from "echarts";
  import type { MapTile } from "$lib/types/MapTile";
  import {
    getCivilizationColor,
    getTerrainColor,
    getHeightColor,
    getVegetationColor,
    getResourceColor,
  } from "$lib/config";

  export type ColorMode = "political" | "terrain" | "height" | "vegetation" | "resource";

  let {
    tiles,
    height = "600px",
  }: {
    tiles: MapTile[];
    height?: string;
  } = $props();

  let colorMode = $state<ColorMode>("political");
  let chartContainer: HTMLDivElement;
  let chart: echarts.ECharts | null = null;

  const COLOR_MODES: { value: ColorMode; label: string }[] = [
    { value: "political", label: "Political" },
    { value: "terrain", label: "Terrain" },
    { value: "height", label: "Elevation" },
    { value: "vegetation", label: "Vegetation" },
    { value: "resource", label: "Resources" },
  ];

  // Hex geometry constants (flat-top orientation)
  const HEX_SIZE = 10;
  const HEX_WIDTH = HEX_SIZE * 2;
  const HEX_HEIGHT = Math.sqrt(3) * HEX_SIZE;

  function hexToPixel(x: number, y: number): [number, number] {
    const px = x * HEX_WIDTH * 0.75;
    const py = y * HEX_HEIGHT + (x % 2 === 1 ? HEX_HEIGHT / 2 : 0);
    return [px, py];
  }

  function hexVertices(cx: number, cy: number, size: number): number[][] {
    const vertices: number[][] = [];
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i;
      vertices.push([
        cx + size * Math.cos(angle),
        cy + size * Math.sin(angle),
      ]);
    }
    return vertices;
  }

  function getTileColor(tile: MapTile, mode: ColorMode): string {
    switch (mode) {
      case "political":
        if (tile.owner_nation) {
          return getCivilizationColor(tile.owner_nation.replace("NATION_", "")) ?? getTerrainColor(tile.terrain);
        }
        return getTerrainColor(tile.terrain);
      case "terrain":
        return getTerrainColor(tile.terrain);
      case "height":
        return getHeightColor(tile.height);
      case "vegetation":
        return getVegetationColor(tile.vegetation);
      case "resource":
        return tile.resource ? getResourceColor(tile.resource) : getTerrainColor(tile.terrain);
      default:
        return getTerrainColor(tile.terrain);
    }
  }

  function buildChartOption(mode: ColorMode) {
    if (!tiles.length) return null;

    return {
      backgroundColor: "#1a1a1a",
      animation: false,
      tooltip: {
        trigger: "item",
        formatter: (params: { data: { tile: MapTile } }) => {
          const t = params.data.tile;
          const lines = [`<b>(${t.x}, ${t.y})</b>`];
          if (mode === "political" && t.owner_nation) {
            lines.push(`Owner: ${t.owner_nation.replace("NATION_", "")}`);
          }
          if (mode === "terrain" && t.terrain) {
            lines.push(`Terrain: ${t.terrain.replace("TERRAIN_", "")}`);
          }
          if (mode === "height" && t.height) {
            lines.push(`Height: ${t.height.replace("HEIGHT_", "")}`);
          }
          if (mode === "vegetation" && t.vegetation) {
            lines.push(`Vegetation: ${t.vegetation.replace("VEGETATION_", "")}`);
          }
          if (mode === "resource" && t.resource) {
            lines.push(`Resource: ${t.resource.replace("RESOURCE_", "")}`);
          }
          return lines.join("<br/>");
        },
      },
      xAxis: { show: false, min: "dataMin", max: "dataMax" },
      yAxis: { show: false, min: "dataMin", max: "dataMax", inverse: true },
      dataZoom: [
        { type: "inside", xAxisIndex: 0, minSpan: 10 },
        { type: "inside", yAxisIndex: 0, minSpan: 10 },
      ],
      series: [{
        type: "custom",
        coordinateSystem: "cartesian2d",
        renderItem: (params: unknown, api: {
          value: (idx: number) => number;
          coord: (val: [number, number]) => [number, number];
          style: (opts: { fill: string }) => Record<string, unknown>;
        }) => {
          const px = api.value(0) as number;
          const py = api.value(1) as number;
          const color = api.value(2) as unknown as string;
          const [cx, cy] = api.coord([px, py]);

          return {
            type: "polygon",
            shape: { points: hexVertices(cx, cy, HEX_SIZE * 0.95) },
            style: api.style({ fill: color }),
          };
        },
        data: tiles.map((tile) => {
          const [px, py] = hexToPixel(tile.x, tile.y);
          return {
            value: [px, py, getTileColor(tile, mode)],
            tile,
          };
        }),
      }],
    };
  }

  const chartOption = $derived(buildChartOption(colorMode));

  onMount(() => {
    let resizeObserver: ResizeObserver;

    const initChart = () => {
      if (!chartContainer || chartContainer.clientWidth === 0) return;
      if (!chart) {
        chart = echarts.init(chartContainer);
        if (chartOption) chart.setOption(chartOption as any);
      }
    };

    tick().then(() => {
      initChart();
      resizeObserver = new ResizeObserver(() => {
        if (!chart && chartContainer) initChart();
        chart?.resize();
      });
      resizeObserver.observe(chartContainer);
    });

    window.addEventListener("resize", () => chart?.resize());

    return () => {
      resizeObserver?.disconnect();
      chart?.dispose();
    };
  });

  $effect(() => {
    const opt = chartOption;
    if (chart && opt) {
      chart.setOption(opt as any, true);
    }
  });
</script>

<div class="flex flex-col gap-4">
  <!-- Color mode selector -->
  <div class="flex gap-2">
    {#each COLOR_MODES as mode}
      <button
        class="px-4 py-2 rounded border-2 border-black font-bold text-sm transition-colors"
        class:bg-brown={colorMode === mode.value}
        class:text-tan={colorMode === mode.value}
        class:bg-transparent={colorMode !== mode.value}
        class:text-brown={colorMode !== mode.value}
        class:hover:bg-brown/30={colorMode !== mode.value}
        onclick={() => colorMode = mode.value}
      >
        {mode.label}
      </button>
    {/each}
  </div>

  <!-- Map container -->
  <div class="w-full" style="height: {height}">
    <div bind:this={chartContainer} class="w-full h-full"></div>
  </div>
</div>
```

### 2.3 Simplify Game Details Page

**`src/routes/game/[id]/+page.svelte`** - Update Map tab content (remove colorMode prop since it's now internal):

```svelte
<Tabs.Content
	value="map"
	class="tab-pane min-h-[400px] rounded-b-lg border-2 border-t-0 border-black p-8"
	style="background-color: #35302B;"
>
	<h2 class="mb-4 mt-0 font-bold text-tan">World Map</h2>
	{#if mapTiles}
		<HexMap tiles={mapTiles} height="600px" />
	{:else}
		<p class="italic text-brown">Loading map data...</p>
	{/if}
</Tabs.Content>
```

### 2.4 Unit Tests

No frontend test framework is configured. The terrain color functions are simple lookup tables that will be validated during manual testing of the map visualization.
